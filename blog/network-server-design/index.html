<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.141.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple-touch-icon.png><meta itemprop=name content="网络服务器设计原理及分析"><meta itemprop=description content="To Figure Out How Stuff Works."><meta name=description content="To Figure Out How Stuff Works."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/my_avatar.jpg"><meta itemprop=keywords content="服务器,事件驱动"><meta property="og:type" content="article"><meta property="og:title" content="网络服务器设计原理及分析"><meta property="og:description" content="To Figure Out How Stuff Works."><meta property="og:image" content="/imgs/my_avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/blog/network-server-design/"><meta property="og:site_name" content="心有所住"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Don't Panic"><meta property="article:published_time" content="2025-02-25 10:00:44 +0800 +0800"><meta property="article:modified_time" content="2025-02-25 10:00:44 +0800 +0800"><link type=text/css rel=stylesheet href=/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.45d29d57a24f13fadbc1a0ea33c4bd8eee69481dc030f24b2244feda4b2df64a.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"network-server-design","permalink":"/blog/network-server-design/","title":"网络服务器设计原理及分析","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>网络服务器设计原理及分析 - 心有所住</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>心有所住</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Don't Wish It Was Easier. Wish You Were Better.</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-th hvr-icon"></i>分类</a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tags hvr-icon"></i>标签</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>1</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#一操作系统基础>一、操作系统基础</a><ul><li><a href=#用户空间与内核空间>用户空间与内核空间</a></li><li><a href=#进程切换>进程切换</a></li><li><a href=#文件描述符>文件描述符</a></li><li><a href=#缓存io>缓存I/O</a><ul><li><a href=#阻塞-ioblocking-io>阻塞 I/O（Blocking IO）</a></li><li><a href=#非阻塞-iononblocking-io>非阻塞 I/O（Nonblocking IO）</a></li><li><a href=#io-多路复用-io-multiplexing>I/O 多路复用（ IO multiplexing）</a></li><li><a href=#信号驱动-io-signal-driven-io>信号驱动 I/O（ Signal driven IO）</a></li><li><a href=#异步-ioasynchronous-io>异步 I/O（Asynchronous IO）</a></li><li><a href=#各个io-model的比较>各个I/O Model的比较</a></li></ul></li></ul></li><li><a href=#二io-多路复用之selectpollepoll>二、I/O 多路复用之select、poll、epoll</a><ul><li><a href=#select>select</a></li><li><a href=#poll>poll</a></li><li><a href=#epoll>epoll</a></li><li><a href=#slectpollepoll之间的区别>slect/poll/epoll之间的区别</a></li></ul></li><li><a href=#三libevent源码剖析v2112-stable>三、libevent源码剖析（v2.1.12-stable）</a><ul><li><a href=#reactor事件处理机制>Reactor事件处理机制</a></li><li><a href=#使用示例>使用示例</a></li><li><a href=#libevent支持多线程>Libevent支持多线程</a></li></ul></li><li><a href=#四muduo源码剖析>四、muduo源码剖析</a></li><li><a href=#五协程>五、协程</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="Don't Panic" src=/imgs/img-lazy-loading.gif data-src=/imgs/my_avatar.jpg><p class=site-author-name itemprop=name>Don't Panic</p><div class=site-description itemprop=description>To Figure Out How Stuff Works.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>1</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>1</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>2</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/weicao0 title="Github → https://github.com/weicao0" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i>
Links</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://dccxi.com/trust/ title=https://dccxi.com/trust/ target=_blank>信任的进化</a></li><li class=links-of-blogroll-item><a href=/linux-c-book title=/linux-c-book target=_blank>Linux C编程一站式学习</a></li><li class=links-of-blogroll-item><a href=/life-js title=/life-js target=_blank>生命游戏</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/blog/network-server-design/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/my_avatar.jpg"><meta itemprop=name content="Don't Panic"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Don't Panic"><meta itemprop=description content="To Figure Out How Stuff Works."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="网络服务器设计原理及分析"><meta itemprop=description content="在网络服务端编程中，服务器需要处理多个客户端的请求。为了提高性能，服务器通常会使用多种手段并发处理这些请求。基于非阻塞IO和事件驱动的并发机制可能是编写用户态高性能网络程序最成熟的模式。"></span><header class=post-header><h1 class=post-title itemprop="name headline">网络服务器设计原理及分析</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2025-02-25 10:00:44 +0800 +0800" itemprop="dateCreated datePublished" datetime="2025-02-25 10:00:44 +0800 +0800">2025-02-25
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E6%8A%80%E6%9C%AF itemprop=url rel=index><span itemprop=name>技术</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>14727</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>30分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/blog/network-server-design/><i class="fa fa-sync fa-spin"></i>
</span></span><span class=post-meta-item title><span class=post-meta-item-icon><i class="fas fa-solid fa-comments"></i>
</span><span class=post-meta-item-text title=评论>评论：
</span><span id=comments-count class=waline-comment-count data-path=/blog/network-server-design/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>在网络服务端编程中，服务器需要处理多个客户端的请求。为了提高性能，服务器通常会使用多种手段并发处理这些请求。基于非阻塞IO和事件驱动的并发机制可能是编写用户态高性能网络程序最成熟的模式。</p><h2 id=一操作系统基础>一、操作系统基础
<a class=header-anchor href=#%e4%b8%80%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80></a></h2><h3 id=用户空间与内核空间>用户空间与内核空间
<a class=header-anchor href=#%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e4%b8%8e%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4></a></h3><p>操作系统都采用虚拟存储器，系统可访问的虚拟存储空间就是系统自身的寻址空间，例如32位操作系统对应4G（2的32次方）的寻址空间。操作系统通过内核（kernel）访问底层硬件设备，用户进程则由内核进行调度管理。为了保证用户进程不直接操作内核，系统将虚拟存储空间分为内核空间和用户空间两部分。针对32位linux操作系统而言，将最高的1G字节（虚拟地址0xC0000000-0xFFFFFFFF）分配为内核空间，较低的3G字节（虚拟地址0x00000000-0xBFFFFFFF）分配为用户空间。</p><h3 id=进程切换>进程切换
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e5%88%87%e6%8d%a2></a></h3><p>内核进行进程切换时，主要有下列处理过程：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新内核空间中的PCB（进程控制块Process Control Block）信息。</li><li>把进程的PCB移入相应的队列，如就绪、某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ul><p>总而言之，进程切换很耗费资源。</p><p>进程有就绪、运行、阻塞三种基本状态。正在运行的进程，会因为请求系统资源失败、等待操作完成、新数据未到达或无新工作做等原因由系统自动执行阻塞原语（Block），使自己从运行状态变为阻塞状态，从而退出CPU资源的占用。</p><h3 id=文件描述符>文件描述符
<a class=header-anchor href=#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6></a></h3><p>当程序打开现有文件或新建文件时，内核会维护一个该进程打开文件的记录表，并通过文件描述符（File Descriptor）来对该文件记录表进行索引。一些涉及底层I/O的程序编写往往会围绕文件描述符展开。</p><h3 id=缓存io>缓存I/O
<a class=header-anchor href=#%e7%bc%93%e5%ad%98io></a></h3><p>当程序进行I/O访问操作时，操作系统会先将I/O的数据缓存到文件系统的页缓存（Page Cache）中，也就是说，数据会先被拷贝到操作系统的内核缓冲区中，再从内核缓冲区拷贝到应用程序的地址空间。因为缓存I/O机制的存在，数据在传输过程中需要在用户空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU及内存开销通常是很大的。以I/O的read操作为例，会经历两个阶段：</p><ul><li>等待数据就绪</li><li>将数据从内核空间拷贝到用户进程空间中</li></ul><p>围绕这两个阶段，Linux系统产生了下面五种网络模式的方案：</p><ul><li>阻塞 I/O（Blocking IO）</li><li>非阻塞 I/O（Nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ Signal driven IO）</li><li>异步 I/O（Asynchronous IO）</li></ul><h4 id=阻塞-ioblocking-io>阻塞 I/O（Blocking IO）
<a class=header-anchor href=#%e9%98%bb%e5%a1%9e-ioblocking-io></a></h4><p>在Linux中，默认情况下所有的socket操作都是blocking，一个典型的read操作流程如下：</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210203164645371.png alt=image-20210203164645371></p><p>对于网络I/O，很多时候数据一开始还没有到达，例如还没有收到完整的UDP数据帧。因此，在用户调用recvfrom后，如果内核数据没有准备好，用户进程首先会被阻塞，kernel需要等待内核缓冲区的数据准备就绪，再将内核缓冲区中的数据拷贝到用户空间，并返回结果给用户进程，用户进程才可以解除block状态，继续运行。总结来说，Blocking I/O的特点就是I/O执行的两个阶段都需要block。</p><h4 id=非阻塞-iononblocking-io>非阻塞 I/O（Nonblocking IO）
<a class=header-anchor href=#%e9%9d%9e%e9%98%bb%e5%a1%9e-iononblocking-io></a></h4><p>Linux下可以通过设置socket属性使其变为non-blocking。对non-blocking socket的read操作如下：</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204095548850.png alt=image-20210204095548850></p><p>用户进程调用recvfrom后，如果kernel中的数据还没有准备好，进程不会被block，而是立刻收到一个error返回值。用户进程可以通过判断返回值结果来决定是继续发送read操作，还是执行其他指令。在后续的read操作中，如果此时kernel中的数据准备好了，系统才会将内核缓冲区中的数据拷贝到用户内存，并返回正常执行结果。总结来说，nonblocking I/O的特点是I/O执行的第一个阶段不需要block，由用户进程来主动询问kernel中的数据是否准备就绪。</p><h4 id=io-多路复用-io-multiplexing>I/O 多路复用（ IO multiplexing）
<a class=header-anchor href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8-io-multiplexing></a></h4><p>I/O 多路复用就是通常使用的select、poll、epoll，也称为event driven I/O。其基本原理就是select/poll/epoll函数（三者的区别见后文）不断的轮询负责的socket I/O，当某个socket有数据到达了，就通知用户进程。</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204101105947.png alt=image-20210204101105947></p><p>用户进程首先调用select函数，整个进程会被block，kernel监视select负责的socket I/O，当任何一个select中的I/O数据准备就绪，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户内存。总结来说，I/O 多路复用的特点是单个进程同时处理多个网络连接I/O，即在进程中通过select/poll/epoll系统调用同时等待多个文件描述符，当这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。因为使用了select、recvfrom两个系统调用，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking I/O的web server性能更好，可能延时还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><h4 id=信号驱动-io-signal-driven-io>信号驱动 I/O（ Signal driven IO）
<a class=header-anchor href=#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8-io-signal-driven-io></a></h4><p>信号驱动式I/O的过程如下图所示：</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204103934532.png alt=image-20210204103934532></p><p>首先注册处理函数到 SIGIO 信号上，然后设置可以接受SIGIO信号的进程ID，最后设置socket使能Signal-driven I/O Flag，此后用户进程继续执行。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p>Signal driven IO对于TCP没什么用，
<a href=http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch25lev1sec2.html title=这篇文章 rel="noopener external nofollow noreferrer" target=_blank class=exturl>这篇文章
<i class="fa fa-external-link-alt"></i>
</a>给出了原因。因为产生的太过频繁，而且很多情况都会产生SIGIO 信号，比如：</p><ul><li>对listening socket，一个连接请求完成</li><li>一个disconnect请求完成初始化</li><li>一个disconnect请求完成</li><li>connection被shut down</li><li>数据到达</li><li>数据被发送</li><li>asynchronous error产生</li></ul><p>对于UDP，有下列情况会产生SIGIO信号：</p><ul><li>数据帧到达</li><li>asynchronous error产生</li></ul><p>因此现在还在使用 Signal Driven IO 的基本是 UDP连接。</p><h4 id=异步-ioasynchronous-io>异步 I/O（Asynchronous IO）
<a class=header-anchor href=#%e5%bc%82%e6%ad%a5-ioasynchronous-io></a></h4><p>异步I/O的流程如下：</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204102742268.png alt=image-20210204102742268></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。总结来说，Asynchronous I/O的特点就是在I/O执行的两个阶段都不会block用户进程，在收到kernel发送的信号前，用户进程都可以不理睬I/O的处理状态。</p><h4 id=各个io-model的比较>各个I/O Model的比较
<a class=header-anchor href=#%e5%90%84%e4%b8%aaio-model%e7%9a%84%e6%af%94%e8%be%83></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204103548709.png alt=image-20210204103548709></p><p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p><h2 id=二io-多路复用之selectpollepoll>二、I/O 多路复用之select、poll、epoll
<a class=header-anchor href=#%e4%ba%8cio-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e4%b9%8bselectpollepoll></a></h2><p>三者基本的原理是相同的，流程如下</p><ol><li>先依次调用fd对应的struct file.f_op->poll()方法（如果有提供实现的话），尝试检查每个提供待检测IO的fd是否已经有IO事件就绪，并调用__pollwait回调函数将当前进程挂到设备的等待队列中，以便当设备驱动发生自身资源可读写后，唤醒其等待队列上睡眠的进程</li><li>如果已经有IO事件就绪，则直接将所收集到的IO事件返回，本次调用结束</li><li>如果暂时没有IO事件就绪，则根据所给定的超时参数，选择性地进入等待</li><li>如果超时参数指示不等待，则本次调用结束，无IO事件返回</li><li>如果超时参数指示等待（等待一段时间或持续等待），则将当前select/poll/epoll的调用任务挂起</li><li>当所检测的fd任何一个有新的IO事件发生时，会将上述的处于等待的任务唤醒。任务被唤醒之后，重新执行1中的IO事件收集过程。</li></ol><h3 id=select>select
<a class=header-anchor href=#select></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FD_SETSIZE 1024
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NFDBITS (8 * sizeof(unsigned long))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define __FDSET_LONGS (FD_SETSIZE/NFDBITS)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 数据结构 (bitmap)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> fds_bits[__FDSET_LONGS];
</span></span><span style=display:flex><span>} fd_set;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// API
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span> (<span style=color:#66d9ef>int</span> n, fd_set <span style=color:#f92672>*</span>readfds, fd_set <span style=color:#f92672>*</span>writefds, fd_set <span style=color:#f92672>*</span>exceptfds, <span style=color:#66d9ef>struct</span> timeval <span style=color:#f92672>*</span>timeout);			    <span style=color:#75715e>// 返回就绪描述符的数目                        
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>FD_ZERO</span>(<span style=color:#66d9ef>int</span> fd, fd_set<span style=color:#f92672>*</span> fds);   <span style=color:#75715e>// 清空集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FD_SET</span>(<span style=color:#66d9ef>int</span> fd, fd_set<span style=color:#f92672>*</span> fds);    <span style=color:#75715e>// 将给定的描述符加入集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FD_ISSET</span>(<span style=color:#66d9ef>int</span> fd, fd_set<span style=color:#f92672>*</span> fds);  <span style=color:#75715e>// 判断指定描述符是否在集合中 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>FD_CLR</span>(<span style=color:#66d9ef>int</span> fd, fd_set<span style=color:#f92672>*</span> fds);    <span style=color:#75715e>// 将给定的描述符从文件中删除
</span></span></span></code></pre></div><p>select本质上是通过设置或者检查存放fd标志位的数据结构bitmap来进行下一步处理。select函数监视的文件描述符分writefds、readfds、和exceptfds 3类。调用select函数后进程会阻塞，直到有描述符就绪或超时。当select函数返回后，用户进程需要遍历fd_set，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持是它的一个优点。select的缺点在于：</p><ul><li>需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中，考虑到数据拷贝的性能损耗，单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认1024</li><li>每次调用select，都需要把整个fd_set从用户空间拷贝到内核空间，这个开销在fd很多时会很大</li><li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li><li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程</li></ul><p>使用示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 这里进行一些初始化的设置，
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 包括socket建立，地址的设置等,
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fd_set read_fs, write_fs;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> timeval timeout;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 用于记录最大的fd，在轮询中时刻更新即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化比特位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>FD_ZERO</span>(<span style=color:#f92672>&amp;</span>read_fs);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>FD_ZERO</span>(<span style=color:#f92672>&amp;</span>write_fs);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> nfds <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 记录就绪的事件，可以减少遍历的次数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 阻塞获取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 每次需要把fd从用户态拷贝到内核态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nfds <span style=color:#f92672>=</span> <span style=color:#a6e22e>select</span>(max <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>read_fd, <span style=color:#f92672>&amp;</span>write_fd, NULL, <span style=color:#f92672>&amp;</span>timeout);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 每次需要遍历所有fd，判断有无读写事件发生
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> max <span style=color:#f92672>&amp;&amp;</span> nfds; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> listenfd) {
</span></span><span style=display:flex><span>         <span style=color:#f92672>--</span>nfds;
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 这里处理accept事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>FD_SET</span>(i, <span style=color:#f92672>&amp;</span>read_fd);<span style=color:#75715e>//将客户端socket加入到集合中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(i, <span style=color:#f92672>&amp;</span>read_fd)) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>nfds;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里处理read事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(i, <span style=color:#f92672>&amp;</span>write_fd)) {
</span></span><span style=display:flex><span>         <span style=color:#f92672>--</span>nfds;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里处理write事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=poll>poll
<a class=header-anchor href=#poll></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;poll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// 数据结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> pollfd {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;                         <span style=color:#75715e>// 需要监视的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>short</span> events;                   <span style=color:#75715e>// 需要内核监视的事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>short</span> revents;                  <span style=color:#75715e>// 实际发生的事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// API
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>struct</span> pollfd fds[], <span style=color:#66d9ef>nfds_t</span> nfds, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><p>poll本质上和select没有区别，它将用户传入的pollfd数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则返回；如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd，这个过程经历了多次无谓的遍历。</p><p>pollfd没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有缺点：大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</p><p>从上面看，select和poll都需要在返回后，通过遍历pollfd来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p>使用示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// 先宏定义长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define MAX_POLLFD_LEN 4096  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 在这里进行一些初始化的操作，
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 比如初始化数据和socket等。
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> nfds <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  pollfd fds[MAX_POLLFD_LEN];
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(fds, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(fds));
</span></span><span style=display:flex><span>  fds[<span style=color:#ae81ff>0</span>].fd <span style=color:#f92672>=</span> listenfd;
</span></span><span style=display:flex><span>  fds[<span style=color:#ae81ff>0</span>].events <span style=color:#f92672>=</span> POLLRDNORM;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> max  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 队列的实际长度，是一个随时更新的，也可以自定义其他的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> timeout <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> current_size <span style=color:#f92672>=</span> max;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 阻塞获取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 每次需要把fd从用户态拷贝到内核态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nfds <span style=color:#f92672>=</span> <span style=color:#a6e22e>poll</span>(fds, max<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, timeout);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fds[<span style=color:#ae81ff>0</span>].revents <span style=color:#f92672>&amp;</span> POLLRDNORM) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里处理accept事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(listenfd);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//将新的描述符添加到读描述符集合中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 每次需要遍历所有fd，判断有无读写事件发生
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> max; <span style=color:#f92672>++</span>i) {     
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (fds[i].revents <span style=color:#f92672>&amp;</span> POLLRDNORM) { 
</span></span><span style=display:flex><span>         sockfd <span style=color:#f92672>=</span> fds[i].fd
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> ((n <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(sockfd, buf, MAXLINE)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里处理read事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>                fds[i].fd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>         } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>             <span style=color:#75715e>// 这里处理write事件     
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         }
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span>nfds <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;       
</span></span><span style=display:flex><span>         }   
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=epoll>epoll
<a class=header-anchor href=#epoll></a></h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// 数据结构
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每一个epoll对象都有一个独立的eventpoll结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件
</span></span></span><span style=display:flex><span><span style=color:#75715e>// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> eventpoll {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rb_root  rbr;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head rdlist;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//内核需要监视的事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> epoll_event {
</span></span><span style=display:flex><span>  __uint32_t events;  <span style=color:#75715e>/* Epoll events */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>epoll_data_t</span> data;  <span style=color:#75715e>/* User data variable */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>//events可以是以下几个宏的集合：
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLOUT：表示对应的文件描述符可以写；
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLERR：表示对应的文件描述符发生错误；
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLHUP：表示对应的文件描述符被挂断；
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
</span></span></span><span style=display:flex><span><span style=color:#75715e>//EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// API
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span>(<span style=color:#66d9ef>int</span> size); <span style=color:#75715e>// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event); <span style=color:#75715e>// epoll_ctl 负责把 socket 增加、删除到内核红黑树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span> events, <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);<span style=color:#75715e>// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程
</span></span></span></code></pre></div><p>相对于select和poll来说，epoll将I/O监视过程解耦为epoll_create、epoll_ctl和epoll_wait三个部分。用户可以使用epoll_ctl自由地向epoll对象添加和删除事件，这些事件被挂载到红黑树中（红黑树的时间效率是lg(n)），而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，当相应的事件发生时会调用事件绑定的回调方法，这个回调方法会将发生的事件添加到rdlist双链表中。epoll_wait负责等待事件的产生，实际上就是在这个rdlist链表中查看有没有就绪的fd，然后把就绪的事件反馈给用户。总结来说，通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。</p><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。
LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。
ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，除非遇到EAGAIN错误。</p><p>epoll的优点：</p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口，具体数目可以cat /proc/sys/fs/file-max察看）</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递，即epoll使用mmap减少复制开销</li></ul><p>使用示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 在这里进行一些初始化的操作，
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * 比如初始化数据和socket等。
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 内核中创建ep对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    epfd<span style=color:#f92672>=</span><span style=color:#a6e22e>epoll_create</span>(<span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 需要监听的socket放到ep中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,<span style=color:#f92672>&amp;</span>ev);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 阻塞获取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      nfds <span style=color:#f92672>=</span> <span style=color:#a6e22e>epoll_wait</span>(epfd,events,<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>nfds;<span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span>(events[i].data.fd<span style=color:#f92672>==</span>listenfd) {
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 这里处理accept事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              connfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(listenfd);
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 接收新连接写到内核对象中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#a6e22e>epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,<span style=color:#f92672>&amp;</span>ev);
</span></span><span style=display:flex><span>          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (events[i].events <span style=color:#f92672>&amp;</span> EPOLLIN) {
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 这里处理read事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#a6e22e>read</span>(sockfd, BUF, MAXLINE);
</span></span><span style=display:flex><span>              <span style=color:#75715e>//读完后准备写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#a6e22e>epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,<span style=color:#f92672>&amp;</span>ev);
</span></span><span style=display:flex><span>          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(events[i].events <span style=color:#f92672>&amp;</span> EPOLLOUT) {
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 这里处理write事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#a6e22e>write</span>(sockfd, BUF, n);
</span></span><span style=display:flex><span>              <span style=color:#75715e>//写完后准备读
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#a6e22e>epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,<span style=color:#f92672>&amp;</span>ev);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=slectpollepoll之间的区别>slect/poll/epoll之间的区别
<a class=header-anchor href=#slectpollepoll%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab></a></h3><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210204171558596.png alt=image-20210204171558596></p><table><thead><tr><th>系统调用</th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>数据结构</td><td>数组</td><td>链表</td><td>红黑树</td></tr><tr><td>最大连接数</td><td>1024</td><td>无上限</td><td>无上限</td></tr><tr><td>fd拷贝</td><td>每次调用select拷贝</td><td>每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td>工作效率</td><td>轮询：O(n)</td><td>轮询：O(n)</td><td>回调：O(1)</td></tr></tbody></table><p>综上，在选择select、poll、epoll时要根据具体的使用场合以及这三种方式的自身特点：</p><ol><li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li><li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li></ol><h2 id=三libevent源码剖析v2112-stable>三、libevent源码剖析（v2.1.12-stable）
<a class=header-anchor href=#%e4%b8%89libevent%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90v2112-stable></a></h2><h3 id=reactor事件处理机制>Reactor事件处理机制
<a class=header-anchor href=#reactor%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6></a></h3><p>正常事件处理流程是应用程序调用某个接口触发某个功能，而Reactor模式需要我们将这些接口和宿主指针（谁调用这些接口）注册在Reactor，在合适的时机Reactor使用宿主指针调用注册好的回调函数，它具有如下优点：</p><ul><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；</li><li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/
进程的切换开销；</li><li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；</li><li>可复用性， reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性。</li></ul><p>Reactor模式主要部件：</p><ol><li>EventDemultiplexer</li></ol><p>事件多路分发机制，调用系统提供的I/O多路复用机制（select、epoll）。程序先将关注的句柄注册到 EventDemultiplexer 上，当有关注的事件到来时，触发 EventDemultiplexer 通知程序，调用之前注册好的回调函数完成消息相应。对应到 libevent 中，依然是 select、 poll、 epoll 等，但是 libevent 使用结构体eventop进行了封装（位于poll.c/select.c/kqueue.c/devpoll.c中），以统一的接口（init、add、del、dispatch、dealloc函数指针）来支持这些 I/O 多路复用机制，达到了对外隐藏底层系统机制的目的。C++语言提供了虚函数来实现多态，在C语言中，这是通过函数指针实现的。</p><p>Libevent把所有支持的I/O demultiplex机制存储在一个全局静态数组eventops中，并根据系统配置和编译选项决定使用哪一种I/O demultiplex机制，即libevent在编译阶段选择系统的I/O demultiplex机制，而不支持在运行阶段根据配置再次选择。以epoll为例，eventops对象epollops定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> eventop epollops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;epoll&#34;</span>,
</span></span><span style=display:flex><span>	epoll_init,
</span></span><span style=display:flex><span>	epoll_nochangelist_add,
</span></span><span style=display:flex><span>	epoll_nochangelist_del,
</span></span><span style=display:flex><span>	epoll_dispatch,
</span></span><span style=display:flex><span>	epoll_dealloc,
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>1</span>, <span style=color:#75715e>/* need reinit */</span>
</span></span><span style=display:flex><span>	EV_FEATURE_ET<span style=color:#f92672>|</span>EV_FEATURE_O1<span style=color:#f92672>|</span>EV_FEATURE_EARLY_CLOSE,
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>libevent调用结构体eventop的init和dispatch函数指针时，实际调用的函数就是epoll的初始化函数epoll_init()和事件分发函数epoll_dispatch()。</p><ol start=2><li>Reactor</li></ol><p>事件管理的接口，内部使用 EventDemultiplexer 注册、注销事件；根据系统提供的事件多路分发机制执行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。对应到 libevent 中，就是 event_base 结构体（位于event-internal.h中）和事件注册、注销等接口函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span>  <span style=color:#a6e22e>event_add</span>(<span style=color:#66d9ef>struct</span> event <span style=color:#f92672>*</span>ev, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> timeval <span style=color:#f92672>*</span>timeout);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>  <span style=color:#a6e22e>event_del</span>(<span style=color:#66d9ef>struct</span> event <span style=color:#f92672>*</span>ev);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>  <span style=color:#a6e22e>event_base_loop</span>(<span style=color:#66d9ef>struct</span> event_base <span style=color:#f92672>*</span>base, <span style=color:#66d9ef>int</span> loops);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>event_active</span>(<span style=color:#66d9ef>struct</span> event <span style=color:#f92672>*</span>event, <span style=color:#66d9ef>int</span> res, <span style=color:#66d9ef>short</span> events);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>event_process_active</span>(<span style=color:#66d9ef>struct</span> event_base <span style=color:#f92672>*</span>base);
</span></span></code></pre></div><p>创建了一个新的libevent实例时，程序需要通过调用event_base_new函数来创建创建一个event_base对象，该函数同时还对新生成的libevent实例进行了初始化，首先为event_base实例申请空间，然后初始化timeheap，选择合适的系统I/O的demultiplexer机制初始化各事件链表；函数还检测了系统的时间设置，为后面的时间管理打下基础。注册和删除事件的流程类似（event.c中的event_add_nolock_、event_del_nolock_）。</p><p>在event_base_loop中，libevent根据系统提供的事件多路分发机制执行事件主循环。流程如下：</p><ul><li>首先判断退出循环的标记是否置位(event_gotterm和event_break),如果置位,直接退出循环</li><li>校正系统时间(将tv赋值)</li><li>根据最小超时时间,计算最近的等待时间,如果有未处理的激活事件或者设置了非阻塞标志,则无需等待(定时时间设为0)</li><li>如果没有注册事件,则退出;否则调用多路I/O机制的等待函数</li><li>之后便检测小根堆中是否有超时事件,如果有,将其从小根堆移入激活事件链表中</li><li>接下来,如果有激活事件,则进行处理。并且如果要求执行到当前激活链表中没有事件可以执行就退出或者设置的是非阻塞,则下次就退出循环。</li></ul><p>Libevent将Timer和Signal事件都统一到了系统的I/O 的demultiplex机制中。</p><p>系统的I/O机制像select()和epoll_wait()都允许程序制定一个最大等待时间（也称为最大超时时间）timeout，即使没有I/O事件发生，它们也保证能在timeout时间内返回。那么根据所有Timer事件的最小超时时间来设置系统I/O的timeout时间；当系统I/O返回时，再激活所有就绪的Timer事件就可以了，这样就能将Timer事件完美的融合到系统的I/O机制中了。libevent采用堆结构（插入、删除元素时间复杂度都是O(lgN)，而获取最小key值（小根堆）的复杂度为O(1)）来管理Timer事件。</p><p>Signal是异步事件的经典事例，将Signal事件统一到系统的I/O多路复用中就不像Timer事件那么自然了，Signal事件的出现对于进程来讲是完全随机的，进程不能只是测试一个变量来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行如下的操作”。当Signal发生时，libevent并不立即调用event的callback函数处理信号，而是设法通知系统的I/O机制（为socket pair的读socket在libevent的event_base实例上注册一个persist的读事件），让其返回，然后再统一和I/O事件以及Timer一起处理。</p><ol start=3><li>EventHandler</li></ol><p>事件处理程序，提供了一组接口，每个接口对应了一种类型的事件，供 Reactor 在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。对应到 libevent 中，就是 event 结构体（位于event-struct.h中）。</p><p>每次当有事件event转变为就绪状态时，libevent就会把它移入到ev_evcallback中，其中ev_evcallback->priority是event的优先级；接着libevent会根据自己的调度策略（event.c中event_base_loop&#187;event_process_active&#187;event_process_active_single_queue）选择就绪事件，调用ev_evcallback->evcb_callback()函数执行事件处理。</p><h3 id=使用示例>使用示例
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    这是一个示例性质的libevent的程序，监听在TCP的9995端口。
</span></span></span><span style=display:flex><span><span style=color:#75715e>    当连接建立成功后，它将会给Client回应一个消息&#34;Hello, World!\n&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    发送完毕后就将连接关闭。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    程序也处理了SIGINT (ctrl-c)信号，收到这个信号后优雅退出程序。
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    这个程序也用到了一些libevent比较高级的API：“bufferevent”
</span></span></span><span style=display:flex><span><span style=color:#75715e>    这套API将buffer的“水位线”也抽象成了event来处理，灵感应该是来自
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Windows平台的IOCP。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 引入常用Linux系统头文件 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 引入libevent 2.x相关的头文件 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;event2/bufferevent.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;event2/buffer.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;event2/listener.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;event2/util.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;event2/event.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义字符串常量，将会回应给Client用 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> MESSAGE[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// server监听的端口 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> PORT <span style=color:#f92672>=</span> <span style=color:#ae81ff>9995</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义几个event callback的prototype（原型） 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>listener_cb</span>(<span style=color:#66d9ef>struct</span> evconnlistener <span style=color:#f92672>*</span> , <span style=color:#66d9ef>evutil_socket_t</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span> , <span style=color:#66d9ef>int</span> socklen, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>conn_writecb</span>(<span style=color:#66d9ef>struct</span> bufferevent <span style=color:#f92672>*</span> , <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>conn_eventcb</span>(<span style=color:#66d9ef>struct</span> bufferevent <span style=color:#f92672>*</span> , <span style=color:#66d9ef>short</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signal_cb</span>(<span style=color:#66d9ef>evutil_socket_t</span>, <span style=color:#66d9ef>short</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义标准的main函数 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span> argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// event_base是整个event循环必要的结构体 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> event_base <span style=color:#f92672>*</span> base;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// libevent的高级API专为监听的FD使用 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> evconnlistener <span style=color:#f92672>*</span> listener;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 信号处理event指针 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> event <span style=color:#f92672>*</span> signal_event;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 保存监听地址和端口的结构体 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> sockaddr_in sin;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 分配并初始化event_base 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    base <span style=color:#f92672>=</span> <span style=color:#a6e22e>event_base_new</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>base) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果发生任何错误，向stderr（标准错误输出）打一条日志，退出 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 在C语言里，很多返回指针的API都以返回null为出错的返回值 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// if (!base) 等价于 if (base == null) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Could not initialize libevent!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化sockaddr_in结构体，监听在0.0.0.0:9995 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>sin, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(sin));
</span></span><span style=display:flex><span>    sin.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    sin.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(PORT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bind在上面制定的IP和端口，同时初始化listen的事件循环和callback：listener_cb 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 并把listener的事件循环注册在event_base：base上 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    listener <span style=color:#f92672>=</span> <span style=color:#a6e22e>evconnlistener_new_bind</span>(base, listener_cb, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> )base,
</span></span><span style=display:flex><span>        LEV_OPT_REUSEABLE<span style=color:#f92672>|</span>LEV_OPT_CLOSE_ON_FREE, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>struct</span> sockaddr<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>sin,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>sizeof</span>(sin));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>listener) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果发生任何错误，向stderr（标准错误输出）打一条日志，退出 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Could not create a listener!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化信号处理event 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal_event <span style=color:#f92672>=</span> <span style=color:#a6e22e>evsignal_new</span>(base, SIGINT, signal_cb, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> )base);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 把这个callback放入base中 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>signal_event <span style=color:#f92672>||</span> <span style=color:#a6e22e>event_add</span>(signal_event, NULL)<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Could not create/add a signal event!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 程序将在下面这一行内启动event循环，只有在调用event_base_loopexit后 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 才会从下面这个函数返回，并向下执行各种清理函数，导致整个程序退出 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>event_base_dispatch</span>(base);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 各种清理free 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evconnlistener_free</span>(listener);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event_free</span>(signal_event);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event_base_free</span>(base);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;done</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 监听端口的event callback 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>listener_cb</span>(<span style=color:#66d9ef>struct</span> evconnlistener <span style=color:#f92672>*</span> listener, <span style=color:#66d9ef>evutil_socket_t</span> fd,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span> sa, <span style=color:#66d9ef>int</span> socklen, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> user_data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> event_base <span style=color:#f92672>*</span> base <span style=color:#f92672>=</span> user_data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> bufferevent <span style=color:#f92672>*</span> bev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 新建一个bufferevent，设定BEV_OPT_CLOSE_ON_FREE， 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 保证bufferevent被free的时候fd也会被关闭 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bev <span style=color:#f92672>=</span> <span style=color:#a6e22e>bufferevent_socket_new</span>(base, fd, BEV_OPT_CLOSE_ON_FREE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>bev) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error constructing bufferevent!&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>event_base_loopbreak</span>(base);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设定写buffer的event和其它event 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bufferevent_setcb</span>(bev, NULL, conn_writecb, conn_eventcb, NULL);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开启向fd中写的event 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bufferevent_enable</span>(bev, EV_WRITE);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 关闭从fd中读写入buffer的event 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bufferevent_disable</span>(bev, EV_READ);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 向buffer中写入&#34;Hello, World!\n&#34; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 上面的操作保证在fd可写时，将buffer中的内容写出去 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bufferevent_write</span>(bev, MESSAGE, <span style=color:#a6e22e>strlen</span>(MESSAGE));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 每次fd可写，数据非阻塞写入后，会调用conn_writecb 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 这个函数每次检查eventbuffer的剩余大小，如果为0表示数据已经全部写完，将eventbuffer free掉 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 由于在上面设定了BEV_OPT_CLOSE_ON_FREE，所以fd也会被关闭 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>conn_writecb</span>(<span style=color:#66d9ef>struct</span> bufferevent <span style=color:#f92672>*</span> bev, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> user_data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> evbuffer <span style=color:#f92672>*</span> output <span style=color:#f92672>=</span> <span style=color:#a6e22e>bufferevent_get_output</span>(bev);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>evbuffer_get_length</span>(output) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;flushed answer</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>bufferevent_free</span>(bev);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 处理读、写event之外的event的callback 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>conn_eventcb</span>(<span style=color:#66d9ef>struct</span> bufferevent <span style=color:#f92672>*</span> bev, <span style=color:#66d9ef>short</span> events, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> user_data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (events <span style=color:#f92672>&amp;</span> BEV_EVENT_EOF) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Client端关闭连接 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Connection closed.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (events <span style=color:#f92672>&amp;</span> BEV_EVENT_ERROR) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 连接出错 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Got an error on the connection: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果还有其它的event没有处理，那就关闭这个bufferevent 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bufferevent_free</span>(bev);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 信号处理event，收到SIGINT (ctrl-c)信号后，延迟2s退出event循环 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>signal_cb</span>(<span style=color:#66d9ef>evutil_socket_t</span> sig, <span style=color:#66d9ef>short</span> events, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> user_data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> event_base <span style=color:#f92672>*</span> base <span style=color:#f92672>=</span> user_data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> timeval delay <span style=color:#f92672>=</span> { <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Caught an interrupt signal; exiting cleanly in two seconds.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event_base_loopexit</span>(base, <span style=color:#f92672>&amp;</span>delay);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=libevent支持多线程>Libevent支持多线程
<a class=header-anchor href=#libevent%e6%94%af%e6%8c%81%e5%a4%9a%e7%ba%bf%e7%a8%8b></a></h3><p>Libevent本身不是多线程安全的，因此不能直接将event_base_dispatch、event_add等粗暴的使用多线程拆分。合适的做法是实例化多个libevent，每个线程都是一个单独的libevent实例。
<a href=http://memcached.org/ title=memcached rel="noopener external nofollow noreferrer" target=_blank class=exturl>memcached
<i class="fa fa-external-link-alt"></i>
</a>的多线程模型即使用此种机制，并且采用队列和消息通知机制处理各个连接。
<img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210209113435980.png alt=image-20210209113435980></p><h2 id=四muduo源码剖析>四、muduo源码剖析
<a class=header-anchor href=#%e5%9b%9bmuduo%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90></a></h2><p>TCP网络编程的实质是处理连接的建立（socket、bind、list、accept）、消息到达（recv）、消息发送完毕（send）、连接的断开(close)这几个事件。muduo针对这几个事件抽象出了EventLoop、Acceptor/Connector、Tcpconnection、Channel核心类。</p><p><img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210219140829291.png alt=image-20210219140829291></p><p>EventLoop负责接收外界的请求，把成功建立的连接（TcpConnection）分配到EventLoopThreadPool中具体的EventLoop中（图中的EventLoop1、EventLoop2、EventLoop3等）。EventLoop总体负责绑定和监听端口，EventLoop调用Acceptor中函数完成bind、listen、accept操作。epoll模型的操作也被封装在了EventLoop中，EventLoop中loop方法中完成对epoll模型的调度。epoll对读写事件的操作封装在了Channel类中。accept描述符注册到epoll中是通过Channel中的enableReading进行的。
<img src=/imgs/img-lazy-loading.gif data-src=assets/image-20210219141520075.png alt=image-20210219141520075></p><ol><li><p>TcpServer类提供了两个可供外界实现的回调函数接口：ConnectionCallback和MessageCallback。在TcpServer的构造函数中初始化了Acceptor和EventLoopThreadPool。Acceptor中创建了socket同时进行了bind；将socket放在了acceptChannel中，在acceptChannel中注册了Acceptor::handleRead函数；绑定了TcpServer::newConnection函数。</p></li><li><p>TcpServer通过start函数调用了EventLoop的runLoop方法。runLoop中执行了Acceptor::listen函数，在此函数中完成了socket的listen操作和注册到epoll模型的操作。</p></li><li><p>当有客户端连接请求时会触发epoll模型，把accept成功的socket放到了TcpConnection中，并按照轮询方式把TcpConnection的socket注册到不同的EventLoop中。当有客户端发起链接时，触发acceptChannel_中注册的Acceptor::handleRead函数，而Acceptor::handleRead中继续调用了Acceptor中注册的TcpServer::newConnection。在TcpServer::newConnection中，进行了socket的accept操作，并生成了新的TcpConnection。后续在runInLoop中调用了TcpConnection::connectEstablished方法，将socket注册到EventLoopThreadPool中的EventLoop中，并调用了在TcpServer中注册的ConnectionCallback函数。</p></li><li><p>epoll模型开始等待外界发送请求，这时会触发channel_的handRead方法，在handRead中读取了请求，然后调用了TcpServer中注册的messageCallback_方法，也就是业务逻辑的主要实现函数。messageCallback_方法中不仅包含处理请求的逻辑，还必须考虑怎样返回结果，其中一种可选方式是调用TcpConnection的send方法发送结果。</p></li></ol><p>muduo 默认也是单线程模型的，即只有一个线程，里面对应一个 EventLoop。多线程模型的介绍可以参考
<a href=https://www.cyhone.com/articles/analysis-of-muduo/ title=这篇文章 rel="noopener external nofollow noreferrer" target=_blank class=exturl>这篇文章
<i class="fa fa-external-link-alt"></i>
</a>。</p><h2 id=五协程>五、协程
<a class=header-anchor href=#%e4%ba%94%e5%8d%8f%e7%a8%8b></a></h2><p>综合上文所述，早期解决C10K问题的办法是依赖于操作系统提供的I/O复用操作，也就是 epoll/IOCP 多路复用加线程池技术来实现的。本质上这类程序会维护一个复杂的状态机，采用异步的方式编码（消息机制或者是回调函数）。很多用 C/C++ 实现的框架都是这个套路，缺点在于这样的代码一般比较复杂，特别是异步编码加状态机的模式对于程序员是一个很大的挑战。但是从另外一个角度看，符合人类逻辑思维的操作方式却恰恰是同步的。</p><p>在Python等程序语言中，协程的引入可以用来替代回调以简化问题，即以近似同步代码的编程模式实现异步回调机制，在形式上和真实业务同步线性的推演逻辑保持一致。协程可以直接利用代码的执行位置来表示状态，而回调则是携带了一堆数据结构来处理状态或管理上下文。在典型的服务场景中：任务A被拆分为任务B和任务C，如果B和C执行时间不确定（比如要查数据库），那么为了充分提升效率很有必要做成异步机制。如果回调层次比较深、回调次数比较多，就得一直带着一大串额外的回调信息。这时候不得不承认，协程的封装显得非常有必要，这种设计可以避免把共享的状态接力似的传递给每一个回调（在非OOP编程风格的场景下表现得尤为突出）。</p><p>以下载10篇网页的爬虫代码为例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#回调写法</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#75715e># encoding: utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> socket
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> selectors <span style=color:#f92672>import</span> DefaultSelector, EVENT_WRITE, EVENT_READ
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>selector <span style=color:#f92672>=</span> DefaultSelector()
</span></span><span style=display:flex><span>stopped <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>urls_todo <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;/&#39;</span>, <span style=color:#e6db74>&#39;/1&#39;</span>, <span style=color:#e6db74>&#39;/2&#39;</span>, <span style=color:#e6db74>&#39;/3&#39;</span>, <span style=color:#e6db74>&#39;/4&#39;</span>, <span style=color:#e6db74>&#39;/5&#39;</span>, <span style=color:#e6db74>&#39;/6&#39;</span>, <span style=color:#e6db74>&#39;/7&#39;</span>, <span style=color:#e6db74>&#39;/8&#39;</span>, <span style=color:#e6db74>&#39;/9&#39;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Crawler</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, url):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> url
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sock <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>response <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetch</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sock <span style=color:#f92672>=</span> socket<span style=color:#f92672>.</span>socket()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>setblocking(<span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>connect((<span style=color:#e6db74>&#39;example.com&#39;</span>, <span style=color:#ae81ff>80</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>BlockingIOError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        selector<span style=color:#f92672>.</span>register(self<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>fileno(), EVENT_WRITE, self<span style=color:#f92672>.</span>connected)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>connected</span>(self, key, mask):
</span></span><span style=display:flex><span>        selector<span style=color:#f92672>.</span>unregister(key<span style=color:#f92672>.</span>fd)
</span></span><span style=display:flex><span>        get <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GET </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74> HTTP/1.0</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>Host: example.com</span><span style=color:#ae81ff>\r\n\r\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>url)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>send(get<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;ascii&#39;</span>))
</span></span><span style=display:flex><span>        selector<span style=color:#f92672>.</span>register(key<span style=color:#f92672>.</span>fd, EVENT_READ, self<span style=color:#f92672>.</span>read_response)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_response</span>(self, key, mask):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>global</span> stopped
</span></span><span style=display:flex><span>        <span style=color:#75715e># 如果响应大于4KB，下一次循环会继续读</span>
</span></span><span style=display:flex><span>        chunk <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>recv(<span style=color:#ae81ff>4096</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> chunk:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>response <span style=color:#f92672>+=</span> chunk
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            selector<span style=color:#f92672>.</span>unregister(key<span style=color:#f92672>.</span>fd)
</span></span><span style=display:flex><span>            urls_todo<span style=color:#f92672>.</span>remove(self<span style=color:#f92672>.</span>url)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> urls_todo:
</span></span><span style=display:flex><span>                stopped <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>loop</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> stopped:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 阻塞, 直到一个事件发生</span>
</span></span><span style=display:flex><span>        events <span style=color:#f92672>=</span> selector<span style=color:#f92672>.</span>select()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> event_key, event_mask <span style=color:#f92672>in</span> events:
</span></span><span style=display:flex><span>            callback <span style=color:#f92672>=</span> event_key<span style=color:#f92672>.</span>data
</span></span><span style=display:flex><span>            callback(event_key, event_mask)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>    start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> url <span style=color:#f92672>in</span> urls_todo:
</span></span><span style=display:flex><span>        crawler <span style=color:#f92672>=</span> Crawler(url)
</span></span><span style=display:flex><span>        crawler<span style=color:#f92672>.</span>fetch()
</span></span><span style=display:flex><span>    loop()
</span></span><span style=display:flex><span>    print(time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> start)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#协程写法</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#75715e># encoding: utf-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> socket
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> selectors <span style=color:#f92672>import</span> DefaultSelector, EVENT_WRITE, EVENT_READ
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>selector <span style=color:#f92672>=</span> DefaultSelector()
</span></span><span style=display:flex><span>stopped <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>urls_todo <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;/&#39;</span>, <span style=color:#e6db74>&#39;/1&#39;</span>, <span style=color:#e6db74>&#39;/2&#39;</span>, <span style=color:#e6db74>&#39;/3&#39;</span>, <span style=color:#e6db74>&#39;/4&#39;</span>, <span style=color:#e6db74>&#39;/5&#39;</span>, <span style=color:#e6db74>&#39;/6&#39;</span>, <span style=color:#e6db74>&#39;/7&#39;</span>, <span style=color:#e6db74>&#39;/8&#39;</span>, <span style=color:#e6db74>&#39;/9&#39;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>connect</span>(sock, address):
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> Future()
</span></span><span style=display:flex><span>    sock<span style=color:#f92672>.</span>setblocking(<span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        sock<span style=color:#f92672>.</span>connect(address)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>BlockingIOError</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>on_connected</span>():
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span>set_result(<span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    selector<span style=color:#f92672>.</span>register(sock<span style=color:#f92672>.</span>fileno(), EVENT_WRITE, on_connected)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield from</span> f
</span></span><span style=display:flex><span>    selector<span style=color:#f92672>.</span>unregister(sock<span style=color:#f92672>.</span>fileno())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read</span>(sock):
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> Future()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>on_readable</span>():
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span>set_result(sock<span style=color:#f92672>.</span>recv(<span style=color:#ae81ff>4096</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    selector<span style=color:#f92672>.</span>register(sock<span style=color:#f92672>.</span>fileno(), EVENT_READ, on_readable)
</span></span><span style=display:flex><span>    chunk <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield from</span> f
</span></span><span style=display:flex><span>    selector<span style=color:#f92672>.</span>unregister(sock<span style=color:#f92672>.</span>fileno())
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chunk
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_all</span>(sock):
</span></span><span style=display:flex><span>    response <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    chunk <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield from</span> read(sock)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> chunk:
</span></span><span style=display:flex><span>        response<span style=color:#f92672>.</span>append(chunk)
</span></span><span style=display:flex><span>        chunk <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield from</span> read(sock)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(response)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Future</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>result <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_callbacks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_done_callback</span>(self, fn):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_callbacks<span style=color:#f92672>.</span>append(fn)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_result</span>(self, result):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>result <span style=color:#f92672>=</span> result
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> fn <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>_callbacks:
</span></span><span style=display:flex><span>            fn(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __iter__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> self
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Crawler</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, url):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> url
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>response <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fetch</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>global</span> stopped
</span></span><span style=display:flex><span>        sock <span style=color:#f92672>=</span> socket<span style=color:#f92672>.</span>socket()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield from</span> connect(sock, (<span style=color:#e6db74>&#39;example.com&#39;</span>, <span style=color:#ae81ff>80</span>))
</span></span><span style=display:flex><span>        get <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GET </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74> HTTP/1.0</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>Host: example.com</span><span style=color:#ae81ff>\r\n\r\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(self<span style=color:#f92672>.</span>url)
</span></span><span style=display:flex><span>        sock<span style=color:#f92672>.</span>send(get<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;ascii&#39;</span>))
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>response <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield from</span> read_all(sock)
</span></span><span style=display:flex><span>        urls_todo<span style=color:#f92672>.</span>remove(self<span style=color:#f92672>.</span>url)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> urls_todo:
</span></span><span style=display:flex><span>            stopped <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Task</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, coro):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>coro <span style=color:#f92672>=</span> coro
</span></span><span style=display:flex><span>        f <span style=color:#f92672>=</span> Future()
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span>set_result(<span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>step(f)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>step</span>(self, future):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># send会进入到coro执行, 即fetch, 直到下次yield</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># next_future 为yield返回的对象</span>
</span></span><span style=display:flex><span>            next_future <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>coro<span style=color:#f92672>.</span>send(future<span style=color:#f92672>.</span>result)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>StopIteration</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        next_future<span style=color:#f92672>.</span>add_done_callback(self<span style=color:#f92672>.</span>step)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>loop</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> stopped:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 阻塞, 直到一个事件发生</span>
</span></span><span style=display:flex><span>        events <span style=color:#f92672>=</span> selector<span style=color:#f92672>.</span>select()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> event_key, event_mask <span style=color:#f92672>in</span> events:
</span></span><span style=display:flex><span>            callback <span style=color:#f92672>=</span> event_key<span style=color:#f92672>.</span>data
</span></span><span style=display:flex><span>            callback()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>    start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> url <span style=color:#f92672>in</span> urls_todo:
</span></span><span style=display:flex><span>        crawler <span style=color:#f92672>=</span> Crawler(url)
</span></span><span style=display:flex><span>        Task(crawler<span style=color:#f92672>.</span>fetch())
</span></span><span style=display:flex><span>    loop()
</span></span><span style=display:flex><span>    print(time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> start)
</span></span></code></pre></div><p>协程在实践中的实现方式千差万别，一个简单的原因，是协程本身可以通过许多基本元素构建。基本元素的选取方式不一样，构建出来的协程抽象也就有差别。比如, Lua 语言选取了 create, resume 和 yield 作为基本构建元素, 从调度器层面构建出所谓的“非对程”协程系统。而 Julia 语言绕过调度器，通过在协程内调用 yieldto 函数完成了同样的功能，构建出了一个所谓的对称协程系统。尽管这两个语言使用了同样的 setjmp 库，构造出来的原语却不一样。又比如，许多 C 语言的协程库都使用了 ucontext 库实现，这是因为 POSIX 本身提供了 ucontext 库，不少协程实现是以 ucontext 为蓝本实现的。这些实现，都不可避免地带上了 ucontext 系统的一些基本假设，比如协程间是平等的，一般带有调度器来协调协程等等（比如 libtask 实现，以及 云风的 coroutine 库 ）。Go 语言的一个鲜明特色就是通道（channel）作为一级对象。因此，resume 和 yield 等在其他语言里的原语在 go 里都以通道方式构建。我们还可以举出许多同样的例子。这些风格的差异往往和语言的历史、演化路径和要解决的问题相关，我们不必苛求他们的协程模型一定要如此这般。</p><p>总的来说，协程为协同任务提供了一种运行时抽象。这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。我们无法预测未来，但是可以看到，协程已经成为许多擅长数据处理的语言的一级对象。随着计算机并行性能的提升，用户态任务调度已经成为一种标准的多任务模型。在这样的大趋势下，协程这个简单且有效的模型就显得更加引人注目。</p><p>在性能层面上，协程是一种轻量级的线程，本质上协程就是用户空间下的线程（和线程一样，本质上都是控制流的主动让出和恢复机制），如果把线程/进程当作虚拟“CPU”，协程即跑在这个“CPU”上的线程。协程的开销成本很低，每一个协程仅有一个轻巧的用户态栈空间，因此可以方便的处理并发行为。基于是否使用栈和上下文切换机制，协程的具体实现又可以分为有栈和无栈，这里不展开探讨。</p><h2 id=参考>参考
<a class=header-anchor href=#%e5%8f%82%e8%80%83></a></h2><ol><li><p><a href=https://segmentfault.com/a/1190000003063859 title="Linux IO模式及 select、poll、epoll详解" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Linux IO模式及 select、poll、epoll详解
<i class="fa fa-external-link-alt"></i></a></p></li><li><p><a href=https://blog.csdn.net/xp178171640/article/details/105490027 title=libevent源码深度剖析-张亮 rel="noopener external nofollow noreferrer" target=_blank class=exturl>libevent源码深度剖析-张亮
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>《Linux多线程服务端编程：使用muduo C++网络库》</p></li><li><p><a href=https://www.tuicool.com/articles/BNvUfeb title="编程珠玑番外篇-Q 协程的历史，现在和未来" rel="noopener external nofollow noreferrer" target=_blank class=exturl>编程珠玑番外篇-Q 协程的历史，现在和未来
<i class="fa fa-external-link-alt"></i></a></p></li><li><p><a href=http://jolestar.com/parallel-programming-model-thread-goroutine-actor/ title="并发之痛 Thread，Goroutine，Actor" rel="noopener external nofollow noreferrer" target=_blank class=exturl>并发之痛 Thread，Goroutine，Actor
<i class="fa fa-external-link-alt"></i></a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&amp;mid=2247483720&amp;idx=1&amp;sn=f016c06ddd17765fd50b705fed64429c" title="深入理解 Python 异步编程（上）" rel="noopener external nofollow noreferrer" target=_blank class=exturl>深入理解 Python 异步编程（上）
<i class="fa fa-external-link-alt"></i></a></p></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/%e6%9c%8d%e5%8a%a1%e5%99%a8>服务器
</a><a href=/tags/%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8>事件驱动</a></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/alipay.jpeg alt="Don't Panic - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechatpay.jpeg alt="Don't Panic - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
网络服务器设计原理及分析</li><li class=post-copyright-author><strong>本文作者： </strong>Don't Panic</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/blog/network-server-design/ title=网络服务器设计原理及分析>/blog/network-server-design/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2014 - 2025
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Don't Panic</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.141.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOBi9U784Cnicc","emit":false,"inputposition":"top","mapping":"pathname","reactions":false,"repo":"weicao0/weicao0.github.io","repoid":"MDEwOlJlcG9zaXRvcnkxMDM3NjUyMzE=","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"/3rd"}},"version":"4.6.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"@waline/client","file":"dist/waline.css","name":"waline","version":"2.15.8"},"js":{"alias":"@waline/client","file":"dist/waline.js","name":"waline","version":"2.15.8"}}}</script><script type=text/javascript src=/js/main.min.20eb761b32d1208e9d94dd8350a698549f03c3c89d22c8edb2b50bf49af25648.js defer></script></body></html>